<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>1234</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            touch-action: none;
            perspective: 1000px;
        }

        #number {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 120px;
            font-weight: 700;
            color: white;
            cursor: grab;
            user-select: none;
            letter-spacing: -0.02em;
            transform-origin: center center;
            transform-style: preserve-3d;
        }

        #number:active {
            cursor: grabbing;
        }

        .digit {
            display: inline-block;
            transform-style: preserve-3d;
            position: relative;
        }

        .digit span {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
        }
    </style>
</head>
<body>
    <div id="number"></div>

    <script>
        const numberEl = document.getElementById('number');

        // Create 3D extruded number
        function create3DNumber() {
            const digits = ['1', '2', '3', '4'];
            const depth = 40; // depth of extrusion
            
            digits.forEach(digit => {
                const digitEl = document.createElement('div');
                digitEl.className = 'digit';
                digitEl.textContent = digit;
                
                // Create depth layers
                for (let i = 0; i < depth; i++) {
                    const layer = document.createElement('span');
                    layer.textContent = digit;
                    const brightness = 1 - (i / depth) * 0.7;
                    layer.style.color = `rgba(255, 255, 255, ${brightness})`;
                    layer.style.transform = `translateZ(${-i}px)`;
                    layer.style.textShadow = i === 0 ? '0 0 40px rgba(255,255,255,0.5)' : 'none';
                    digitEl.appendChild(layer);
                }
                
                numberEl.appendChild(digitEl);
            });
        }

        create3DNumber();

        let width = window.innerWidth;
        let height = window.innerHeight;

        // Physics state
        let number = {
            rotationX: 0,
            rotationY: 0,
            rotationZ: 0,
            rotationVelX: 0,
            rotationVelY: 0,
            rotationVelZ: 0,
            scale: 1,
            touchX: 0,
            touchY: 0,
            isDragging: false
        };

        // Physics constants
        const ROTATION_DAMPING = 0.88;
        const ROTATION_SPRING = 0.04;
        const TILT_AMOUNT = 25; // max tilt in degrees

        // Touch/Mouse handlers
        function getPointerPos(e) {
            const touch = e.touches ? e.touches[0] : e;
            return { x: touch.clientX, y: touch.clientY };
        }

        function startDrag(e) {
            e.preventDefault();
            number.isDragging = true;
        }

        function drag(e) {
            if (!number.isDragging) return;
            e.preventDefault();
            
            const pos = getPointerPos(e);
            number.touchX = pos.x;
            number.touchY = pos.y;
        }

        function endDrag(e) {
            if (!number.isDragging) return;
            e.preventDefault();
            number.isDragging = false;
        }

        numberEl.addEventListener('mousedown', startDrag);
        numberEl.addEventListener('touchstart', startDrag);
        window.addEventListener('mousemove', drag);
        window.addEventListener('touchmove', drag, { passive: false });
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        // Physics update
        function updatePhysics() {
            let targetRotX = 0;
            let targetRotY = 0;
            
            if (number.isDragging) {
                // Calculate tilt based on touch position
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Normalize touch position to -1 to 1
                const normX = (number.touchX - centerX) / (width / 2);
                const normY = (number.touchY - centerY) / (height / 2);
                
                // Apply tilt - Y rotation for horizontal, X rotation for vertical
                targetRotY = normX * TILT_AMOUNT;
                targetRotX = -normY * TILT_AMOUNT;
            }
            
            // Spring towards target rotation (or back to 0 if not touching)
            number.rotationVelX += (targetRotX - number.rotationX) * ROTATION_SPRING;
            number.rotationVelY += (targetRotY - number.rotationY) * ROTATION_SPRING;
            number.rotationVelZ += (0 - number.rotationZ) * ROTATION_SPRING;
            
            // Apply rotation velocities
            number.rotationVelX *= ROTATION_DAMPING;
            number.rotationVelY *= ROTATION_DAMPING;
            number.rotationVelZ *= ROTATION_DAMPING;
            
            number.rotationX += number.rotationVelX;
            number.rotationY += number.rotationVelY;
            number.rotationZ += number.rotationVelZ;
        }

        // Render
        function render() {
            // Update number element - stays centered, only rotates
            numberEl.style.transform = `
                translate(-50%, -50%)
                rotateX(${number.rotationX}deg)
                rotateY(${number.rotationY}deg)
                rotateZ(${number.rotationZ}deg)
            `;
            
            // Dynamic shadow based on rotation
            const shadowX = Math.sin(number.rotationY * Math.PI / 180) * 30;
            const shadowY = -Math.sin(number.rotationX * Math.PI / 180) * 30;
            const shadowBlur = 60 + Math.abs(number.rotationX) * 0.8 + Math.abs(number.rotationY) * 0.8;
            
            numberEl.style.filter = `drop-shadow(${shadowX}px ${shadowY}px ${shadowBlur}px rgba(0,0,0,0.5))`;
        }

        // Animation loop
        function animate() {
            updatePhysics();
            render();
            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
        });

        // Start animation
        animate();
    </script>
</body>
</html>